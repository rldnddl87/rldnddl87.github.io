---
title : 만화로 배우는 리눅스 시스템 관리 vol1 - 명령어 & 셸 스크립트 입문(~ing)
categories : [Book]
tags: [Infra, 환경구성]
date: 2020-05-8T14:00:00Z
comments: true
author_profile: false
---

- 이전 회사에서 CentOS를 사용하여 배포하거나 WSL에 설치된 Ubuntu 사용시 명령어가 익숙지 않았다.  
그때마다 필요한 내용들을 검색해서 사용하곤 했었는데 가볍게 공부하며 정리하기위해 책을 구입했다.

---
1. __외부 PC 조정하기 - ssh__
    - SSH(Secure Shell) 사용
    - 명령어 : <code> ssh 사용자명@네트워크주소</code>  
    
2. __임시로 관리자 권한 얻기 - sudo__
    - root는 모든 권한을 가지기 때문에 로그인을 막음
    - 패스워드를 알 경우 임시로 root 권한을 부여한다.
    - <code>sudo 사용할명령어</code>  
     
3. __다양한 문자열을 한번에 검색하자 - grep__
    - grep(global regular expression print)
    - 파일 내용 검색
    - 정규표현식과 함께 사용가능
    - -r(하위 경로까지 전부 탐색)
    - <code>grep -r "key" /app/api/</code>  
    
4. __터미널에서도 대화형 파일을 편집하자 - vim__
    - i(입력) / esc(입력종료)
    - /(검색) -> esc -> n or shift + n으로 검색내용 순차적으로 접근 가능
    - 모드 개념 : 최초 vim 실행시 노멀모드가 실행 i,v 등을 통해 편집 모드로 전환, esc 입력시 노멀모드로 복귀
    - :wq로 편집 종료  

5. __vim에서도 복사 & 붙이기 되돌리기를 하고 싶어 - yank__
    - vim 노멀모드에서 v키와 방향키로 범위 지정한 뒤 y입력 - 복사완료!
    - 붙여넣고 싶은 위치에서 <code>shift + p</code>로 붙여넣기 / 숫자 + shift + p로 붙여넣을 횟수 지정 가능
    - <code>ctrl + z</code> : 일시 정지되며 콘솔 입력창으로 전환됨(편집중이던 vim은 백그라운드로 이동)  
    fg입력시 편집중이던 vim으로 이동(background to forceground)
    - 노멀모드 + u : 되돌리기 // 노멀모드 + ctrl + r : 반대로 되돌리기  
    
6. __갑작스러운 네트워크 끊김에서 복귀하고 싶어(가상 터미널) - tmux__
    - 사용자 - 가상 터미널 - 서버 (연결은 ssh)
    - 일반적인 ssh로 서버에 접속할 경우 접속이 끊어지게 되면(네트워크 장애 등) 서버측에서는 ssh연결이 종료 되었기 때문에 실행중이던 프로세스를 종료한다.(작업하던것들 bye..)
    - 예를들어 ssh로 서버에 원격 접속하여 vim 작업 도중 네트워크가 끊어지면 작업 중이던 vim도 종료가 되지만 가상 터미널 이용시 이를 방지 할 수 있음.
    - 가상 터미널의 경우 중간 다리 역할을 함으로써 접속이 끊어지게 되더라도 실행 중이던 프로세스가 강제 종료되지 않는다.
    - screen, tmux, byobu등이 있음
    - tmux에 대해 알아보자
        - ssh로 서버 접속 후 <code>tmux</code> 명령어 실행
        - 접속이 끊어진 뒤에도 다시 ssh 연결한 뒤 <code>tmux attach</code>입력하면 작업 중이던 가상 터미널로 복귀된다.
        - 작업 중이던 tmux에서 강제로 빠져나오기 : ctrl + b and d(detach) //오래 걸래는 작업도중 ssh를 종료할 수 있다.
        - <code>Ctrl + B</code>이후에 입력키 들로 관리한다.(기존의 다른 명령어와 겹치지 않도록)
            - D(Detach) : 실행 중이던 tmux 가상 터미널에서 빠져나오기
            - C(Create) : 또 다른 가상 터미널 생성하기
            - P(Previous) / N(Next) : 이전/다음 가상 터미널로 스위칭 하기
              
7. __다른 화면도 보면서 작업하고 싶어(화면 분할)__
    - tmux 환경
    - Ctrl + B then "(가로분할) / %(세로분할) : 화면을 2개로 나눈다.(가로 분할뒤 세로로 또다시 분할이 가능하다 0_0;;)
    - Ctrl + B then 방향키 : 화면 커서 이동
    - tmux로 화면을 분할한 뒤 스크롤 사용하기 : Ctrl + B then [ 입력후 마우스 스크롤 또는 방향키
    - 분할선 조정하기 : Ctrl + B 입력 뒤에 Ctrl누른채로 방향키로 분할 크기 조정
    - exit : 분할 종료

8. __최근 실행한 명령어를 호출하고 싶어(명령어 이력)__
    - <code>~/.bash_history</code> 최근 입력한 모든 명령어가 순차적으로 저장되어 있다.
    - Ctrl + R : 최근 명령어 내역에서 검색
    - Ctrl + R 다음 검색어를 입력한 뒤 Ctrl + R을 계속 입력할 경우 해당 키워드를 순차적으로 역순으로 찾게 되는데 이때 지나가버린 내용들은 다시 검색을 할 수 없다.
    - 지나가버린 내용들을 다시 순차적으로 검색할 수 있도록 하려면 <code>~/.bashrc</code>를 vim으로 수정하여 <code>stty stop undef</code>라고 추가해 주어야 한다.
    - bash 설정을 추가한 뒤에는 Ctrl + S로 정방향 검색이 가능해진다.  

9. __오래전에 실행한 명령어를 호출하곳 싶어(명령어 이력 검색)__
    - 명령어 이력에는 오랫동안 사용하지 않은 명령어는 남아있지 않는다.
    - 명령어의 기록 기간을 더 늘리는 법
        - <code>vim ~/.bashrc</code>
        - shift+G를 이용하여 파일의 제일 마지막으로 이동한뒤 하단과 같이 작성(숫자는 둘다 동일하게)
        - <pre>
          export HISTSIZE 10000 //메모리에 저장할 이력의 최대 건수
          export HISTFILESIZE=10000 //.bash_history에 저장할 이력의 최대 건수
          </pre>
    - bash는 실행되면 명령어 이력을 .bash_history라는 파일에서 읽어온뒤 메모리에 저장
    - 그 다음부터 실행 명령어를 찾게 될경우 저장된 메모리에서 검색한다음 추가로 실행되 명령어 또한 메모리에 저장
    - bash가 종료될때 메모리에 있던 명령어 내역을 .bash_history에 저장하여 동기화 한다.
    - tmux를 실행하여 화면을 분할할경우 각각의 bash에서 .bash_history파일을 읽어오고 각각의 메모리를 이용하기때문에
     분할 화면간 명령어 실행 내역이 공유되지 않는다.
     - 아래와 같이 설정하여 각각의 분활 tmux bash에서 명령어내역을 공유하도록 설정할 수 있다.
        <pre>
        vim ~/.bashrc
        
        //add
        function share_history {
            history -a
            history -c
            history -r
        }
        PROMPT_COMMAND='share_history'
        shopt -u histappend
        </pre>
        
10. __네트워크 건너서 파일을 복사하고 싶어 (scp)__
    - scp : Secure CoPy(네트워크를 통해서 파일을 복사)
    - <code>scp A B //A파일을 B로 복사</code>
    - <code> scp ./file.ext 로그인할사용자@접속할 컴퓨터:복사할 경로</code>
    - -r(recursively) 옵션 등을통해 폴더 하위 파일들까지 전부 복사 가능

11. __시스템 과부하를 파악하고 싶어(top)__
    ![](/assets/images/posts/2020-04-28/top.png){: width="50%"}
    - top 명령어를 통해 현재 시스템 사용 정보를 알 수 있다.
    - 이 중, load average를 통해 부하상태를 쉽게 알 수있다.(CPU가 처리하길 기다리는 작업의 개수를 나타냄, 1분당 평균으로 나타냄)
    - %CPU란과 Time+를 함께 살펴보아야한다 얼마나 높은 점유율을 얼마동안 사용했는지를 통해 부하를 판단해야하니까
    - c키를 눌러 실행된 command를 좀 더 상세히 볼 수 있다.
    - q를 눌러 top명령어를 종료 가능
    - 종료할 프로세스의 PID를 <code>kill pid</code>명령어를 통해 종료 가능
    - load average 는 처음부터 1분간, 5분간, 15분간 평균적으로 쌓이는 일의 양을 나타냄
    - cpu가 멀티 코어일 경우는 load average >= cpu 코어개수 가 되면 평균적으로 과부하 상태로 볼 수 있다.

12. __시스템 메모리 부족을 파악하고 싶어(top 표시 전환)__
    - Cpu부하가 낮아도 load average가 높은 경우 : 메모리 부족
    - cpu는 작업 장소로 메모리를 사용한다. 메모리에 여유 공간이 부족하게 되면 최근 사용하지 않고 있는 메모리의 데이터를 하드디스크에 임시로 저장한뒤(스왑아웃),
    해당 데이터가 필요할 경우 다시 임시 저장 데이터를 메모리로 로드하는데(스왑 인) 스왑은 os가 알아서 관리하지만 빈번하게 발생할 경우 I/O대기 시간이 길어진다.
    - 바로 이러한 이유로 메모리 부족시 load average가 증가한다.
    - 필요할때만 실행해서 처리가 끝나면 종료되는 것 : 프로세스
    - 컴퓨터 실행 동안 계속 프로세스를 실행시켜야 하는 것 : 서비스
        - 서비스의 실행,종료는 전용 기동 스크립트를 사용한다.
        <pre>
        sudo service apache2 restart //기타 여러 스크립트가 있다.
        </pre>
    - load average가 높고 스왑이 많이 발생하여 os의 작동에 문제가 발생할 경우 os가 자체적으로 알아서 프로세스들을 강제 종료 시킨다.
    - 정리하면
        - load average가 높아도 cpu는 과부하 상태가 아닐수가 있다(cpu의 코어가 많을 경우..등)
        - 빈 메모리가 부족 -> 스왑이 자주 발생 -> cpu처리가 쌓이고.. -> load average가 높아짐
    - top 명령어 출력 내용을 정렬해 보자
        - <code>shift + m //메모리 사용량 순서로 정렬</code>
        - <code>shift + t //cpu 시간 순서 정렬</code>
        - <code>shift + p //cpu 사용량 순서정렬로 돌아가기</code>

13. __로그 파일에서 필요한 줄만 뽑고 싶어__
    - <code>grep "찾을내용" "찾을 파일"</code> -r옵션 없이 사용하여 해당 파일안에서 일치하는 내용을 검색할 수 있다.
    - 예를들어 로그파일에서 특정 내용을 찾아서 전부 검색하고 싶을 경우
      1. <code>Ctrl + b</code>를 이용하여 tmux를 실행하고 <code>grep</code>을 이용하여 검색한다
      2. 그다음 shift + \를 통해 | 키를 입력한다. 해당 키는 직전에 받은 명령어와 다음에 나오는 명령어를 연결해준다.(이를 파이프라인이라 한다.)
      3. <code>grep "log to find" logFile.txt | less</code> less는 파일의 내용을 출력하는 명령어로 파일 이름과 함께 사용하지만 | 명령어를 통해 열어야할 파일 지정을 전달받기 때문에 생략한다.
      4. <code>grpe "/retro" access.log | grep -v "/live | less</code>이런 식으로 파이프라인을 계속 확장할 수 있다.(v는 문자열을 제외한 내용을 검색한다.)
    - <code>cat</code> : 파일 내용을 그대로 읽어서 출력
      - <code>zcat</code> : gzip형식(.gz, .tgz)의 압축 파일의 내용을 출력
      - <code>xzcat</code> : xz형식 용(.xz 파일)
      - <code>unzip</code>
    - 현재 추가되는 로그만 보고 싶어
      - <code>tail -F access.log</code> : tail은 파일의 끝부분만 출력한다 -F를 통해 파일에 변경된 내용들만 출력할 수 있다.
      - tail명령어와 grep을 파이프라인으로 연결하면... : 원하는 내용이 추가될 경우만 실시간 확인이 가능!!
    - 텍스트를 다루는 명령어를 그룹화해 보자
      - 파일 내용을 다음 명령어에 출력하는 시작 그룹
        - cat / zcat / xzcat / tail -F 등
      - 중간에서 이전 명령어 출력을 가공하는 중간 그룹
        - grep(해당하는 라인만 출력) / sort(정렬) / cut(잘라내기) / uniq(중복 제거) / sed,awk(내용 변경)
      - 이전 명령어 출력을 가공하는 최종 그룹
        - less(스크롤 할 수 있게 출력) / tee(파일을 저장) / wc(줄 수나 문자 수를 카운트) / head(첫 부분만 추출)

14. __작업 절차를 자동화하고 싶어(셸 스크립트)__
    - 파이프 라인이 명령어를 가로로 연결한다면 스크립트는 세로로 연결한다.
    - sudo vim setup.sh라는 명령어로 파일을 생성한다.
         <pre>
         #!/bin/bash --해당 스크립트를 실행할 인터프리터를 지정한다
         순차적으로 작업할 내용을 작성한다
         </pre>
    - 작성이 끝난 뒤에는 실행 권한을 주어야 한다. <code>chmod +x setup.sh</code>
    - 파일 실행할때 <code>/bin/</code>이나 <code>/usr/bin/</code>경로 하위에 파일이 있는것이 아니라면 전체 경로를 입력하여야 실행이 된다.
    - 만일 해당 스크립트가 자동 실행중 에러가 발생한다면?
      - <code>if [ $? != 0 ]; then exit; fi</code>스립트가 문제가 발생하면 종료하는 명령어를 추가할 수 있다.
      - exit를 실행해도 명령어를 실행한 터미널이 종료되는것이 아닌 스크립트를 실행할때 작동하는 별도의 프로세스가 종료되는 것이다.

15. __같은 문자열을 스크립트에서 재사용하고 싶어(셸 변수)__
    - vim에서 잘못된 내용을 일괄 수정할 때
      - vim 노멀 모드에서<code>:%s/원문/수정문/</code>과 같이 입력하면 해당 파일내의 모든 원문이 수정문으로 일괄 수정된다.
    - 반복적으로 사용되는 문자열/파일명 등은 변수에 할당하여 재사용할 수 있다.
      - <code>변수명 = 할당할 내용</code>
      - <code>$변수명 or ${변수명}</code>을 통해 호출 가능하다.
      - 스크립트 안에서도 변수를 할당하고 변수명을 통한 재사용이 물론 가능하다.
      - 실행 명령문 또한 변수에 할당이 가능하다
        - <code>tar_extract="tar xfv"</code> tar xfv 파일명 : 파일 압축 풀기
        - <code>tar_compress="tar cfv"</code> tar cfv 파일명 : 파일 압축하기
        - <code>eval</code> eval은 문자열을 명령어로 실행해준다.
        - 즉 <code> eval "$tar_extract file.tar.gz"</code>와 같이 실행 가능하다.
      - 변수명에 변수명을 할당 가능하다.
        <pre>...
        base=/var/log/apache2
        latest=${base}/access.log
        prev=${base}/access.log.7.gz
        ...
        </pre>

16. __작업 환경과 상태를 정해서 스크립트를 실행하고 싶어(환경 변수)__
    - 보는 중~
---
title : 만화로 배우는 리눅스 시스템 관리 vol1 - 명령어 & 셸 스크립트 입문(~ing)
categories : [Book]
tags: [Infra, 환경구성]
date: 2020-05-8T14:00:00Z
comments: true
author_profile: false
---

- 이전 회사에서 CentOS를 사용하여 배포하거나 WSL에 설치된 Ubuntu 사용시 명령어가 익숙지 않았다.  
그때마다 필요한 내용들을 검색해서 사용하곤 했었는데 가볍게 공부하며 정리하기위해 책을 구입했다.

---
1. 외부 PC 조정하기 - ssh
    - SSH(Secure Shell) 사용
    - 명령어 : <code> ssh 사용자명@네트워크주소</code>  
    
2. 임시로 관리자 권한 얻기 - sudo
    - root는 모든 권한을 가지기 때문에 로그인을 막음
    - 패스워드를 알 경우 임시로 root 권한을 부여한다.
    - <code>sudo 사용할명령어</code>  
     
3. 다양한 문자열을 한번에 검색하자 - grep
    - grep(global regular expression print)
    - 파일 내용 검색
    - 정규표현식과 함께 사용가능
    - -r(하위 경로까지 전부 탐색)
    - <code>grep -r "key" /app/api/</code>  
    
4. 터미널에서도 대화형 파일을 편집하자 - vim
    - i(입력) / esc(입력종료)
    - /(검색) -> esc -> n or shift + n으로 검색내용 순차적으로 접근 가능
    - 모드 개념 : 최초 vim 실행시 노멀모드가 실행 i,v 등을 통해 편집 모드로 전환, esc 입력시 노멀모드로 복귀
    - :wq로 편집 종료  

5. vim에서도 복사 & 붙이기 되돌리기를 하고 싶어 - yank
    - vim 노멀모드에서 v키와 방향키로 범위 지정한 뒤 y입력 - 복사완료!
    - 붙여넣고 싶은 위치에서 <code>shift + p</code>로 붙여넣기 / 숫자 + shift + p로 붙여넣을 횟수 지정 가능
    - <code>ctrl + z</code> : 일시 정지되며 콘솔 입력창으로 전환됨(편집중이던 vim은 백그라운드로 이동)  
    fg입력시 편집중이던 vim으로 이동(background to forceground)
    - 노멀모드 + u : 되돌리기 // 노멀모드 + ctrl + r : 반대로 되돌리기  
    
6. 갑작스러운 네트워크 끊김에서 복귀하고 싶어(가상 터미널) - tmux
    - 사용자 - 가상 터미널 - 서버 (연결은 ssh)
    - 일반적인 ssh로 서버에 접속할 경우 접속이 끊어지게 되면(네트워크 장애 등) 서버측에서는 ssh연결이 종료 되었기 때문에 실행중이던 프로세스를 종료한다.(작업하던것들 bye..)
    - 예를들어 ssh로 서버에 원격 접속하여 vim 작업 도중 네트워크가 끊어지면 작업 중이던 vim도 종료가 되지만 가상 터미널 이용시 이를 방지 할 수 있음.
    - 가상 터미널의 경우 중간 다리 역할을 함으로써 접속이 끊어지게 되더라도 실행 중이던 프로세스가 강제 종료되지 않는다.
    - screen, tmux, byobu등이 있음
    - tmux에 대해 알아보자
        - ssh로 서버 접속 후 <code>tmux</code> 명령어 실행
        - 접속이 끊어진 뒤에도 다시 ssh 연결한 뒤 <code>tmux attach</code>입력하면 작업 중이던 가상 터미널로 복귀된다.
        - 작업 중이던 tmux에서 강제로 빠져나오기 : ctrl + b and d(detach) //오래 걸래는 작업도중 ssh를 종료할 수 있다.
        - <code>Ctrl + B</code>이후에 입력키 들로 관리한다.(기존의 다른 명령어와 겹치지 않도록)
            - D(Detach) : 실행 중이던 tmux 가상 터미널에서 빠져나오기
            - C(Create) : 또 다른 가상 터미널 생성하기
            - P(Previous) / N(Next) : 이전/다음 가상 터미널로 스위칭 하기
              
7. 다른 화면도 보면서 작업하고 싶어(화면 분할)
    - tmux 환경
    - Ctrl + B then "(가로분할) / %(세로분할) : 화면을 2개로 나눈다.(가로 분할뒤 세로로 또다시 분할이 가능하다 0_0;;)
    - Ctrl + B then 방향키 : 화면 커서 이동
    - tmux로 화면을 분할한 뒤 스크롤 사용하기 : Ctrl + B then [ 입력후 마우스 스크롤 또는 방향키
    - 분할선 조정하기 : Ctrl + B 입력 뒤에 Ctrl누른채로 방향키로 분할 크기 조정
    - exit : 분할 종료

8. 최근 실행한 명령어를 호출하고 싶어(명령어 이력)
    - <code>~/.bash_history</code> 최근 입력한 모든 명령어가 순차적으로 저장되어 있다.
    - Ctrl + R : 최근 명령어 내역에서 검색
    - Ctrl + R 다음 검색어를 입력한 뒤 Ctrl + R을 계속 입력할 경우 해당 키워드를 순차적으로 역순으로 찾게 되는데 이때 지나가버린 내용들은 다시 검색을 할 수 없다.
    - 지나가버린 내용들을 다시 순차적으로 검색할 수 있도록 하려면 <code>~/.bashrc</code>를 vim으로 수정하여 <code>stty stop undef</code>라고 추가해 주어야 한다.
    - bash 설정을 추가한 뒤에는 Ctrl + S로 정방향 검색이 가능해진다.  

9. 오래전에 실행한 명령어를 호출하곳 싶어(명령어 이력 검색)
    - 명령어 이력에는 오랫동안 사용하지 않은 명령어는 남아있지 않는다.
    - 명령어의 기록 기간을 더 늘리는 법
        - <code>vim ~/.bashrc</code>
        - shift+G를 이용하여 파일의 제일 마지막으로 이동한뒤 하단과 같이 작성(숫자는 둘다 동일하게)
        - <pre>
          export HISTSIZE 10000 //메모리에 저장할 이력의 최대 건수
          export HISTFILESIZE=10000 //.bash_history에 저장할 이력의 최대 건수
          </pre>
    - bash는 실행되면 명령어 이력을 .bash_history라는 파일에서 읽어온뒤 메모리에 저장
    - 그 다음부터 실행 명령어를 찾게 될경우 저장된 메모리에서 검색한다음 추가로 실행되 명령어 또한 메모리에 저장
    - bash가 종료될때 메모리에 있던 명령어 내역을 .bash_history에 저장하여 동기화 한다.
    - tmux를 실행하여 화면을 분할할경우 각각의 bash에서 .bash_history파일을 읽어오고 각각의 메모리를 이용하기때문에
     분할 화면간 명령어 실행 내역이 공유되지 않는다.
     - 아래와 같이 설정하여 각각의 분활 tmux bash에서 명령어내역을 공유하도록 설정할 수 있다.
        <pre>
        vim ~/.bashrc
        
        //add
        function share_history {
            history -a
            history -c
            history -r
        }
        PROMPT_COMMAND='share_history'
        shopt -u histappend
        </pre>
        
10. 네트워크 건너서 파일을 복사하고 싶어 (scp)
    - scp : Secure CoPy(네트워크를 통해서 파일을 복사)
    - <code>scp A B //A파일을 B로 복사</code>
    - <code> scp ./file.ext 로그인할사용자@접속할 컴퓨터:복사할 경로</code>
    - -r(recursively) 옵션 등을통해 폴더 하위 파일들까지 전부 복사 가능

11. 시스템 과부하를 파악하고 싶어(top)  
    ![](/assets/images/posts/2020-04-28/top.png){: width="50%"}
    - top 명령어를 통해 현재 시스템 사용 정보를 알 수 있다.
    - 이 중, load average를 통해 부하상태를 쉽게 알 수있다.(CPU가 처리하길 기다리는 작업의 개수를 나타냄, 1분당 평균으로 나타냄)
    - %CPU란과 Time+를 함께 살펴보아야한다 얼마나 높은 점유율을 얼마동안 사용했는지를 통해 부하를 판단해야하니까
    - c키를 눌러 실행된 command를 좀 더 상세히 볼 수 있다.
    - q를 눌러 top명령어를 종료 가능
    - 종료할 프로세스의 PID를 <code>kill pid</code>명령어를 통해 종료 가능
    - load average 는 처음부터 1분간, 5분간, 15분간 평균적으로 쌓이는 일의 양을 나타냄
    - cpu가 멀티 코어일 경우는 load average >= cpu 코어개수 가 되면 평균적으로 과부하 상태로 볼 수 있다.

12. 시스템 메모리 부족을 파악하고 싶어(top 표시 전환)
    - Cpu부하가 낮아도 load average가 높은 경우 : 메모리 부족
    - cpu는 작업 장소로 메모리를 사용한다. 메모리에 여유 공간이 부족하게 되면 최근 사용하지 않고 있는 메모리의 데이터를 하드디스크에 임시로 저장한뒤(스왑아웃),
    해당 데이터가 필요할 경우 다시 임시 저장 데이터를 메모리로 로드하는데(스왑 인) 스왑은 os가 알아서 관리하지만 빈번하게 발생할 경우 I/O대기 시간이 길어진다.
    - 바로 이러한 이유로 메모리 부족시 load average가 증가한다.
    - 필요할때만 실행해서 처리가 끝나면 종료되는 것 : 프로세스
    - 컴퓨터 실행 동안 계속 프로세스를 실행시켜야 하는 것 : 서비스
        - 서비스의 실행,종료는 전용 기동 스크립트를 사용한다.
        <pre>
        sudo service apache2 restart //기타 여러 스크립트가 있다.
        </pre>
    - load average가 높고 스왑이 많이 발생하여 os의 작동에 문제가 발생할 경우 os가 자체적으로 알아서 프로세스들을 강제 종료 시킨다.
    - 정리하면
        - load average가 높아도 cpu는 과부하 상태가 아닐수가 있다(cpu의 코어가 많을 경우..등)
        - 빈 메모리가 부족 -> 스왑이 자주 발생 -> cpu처리가 쌓이고.. -> load average가 높아짐
    - top 명령어 출력 내용을 정렬해 보자
        - <code>shift + m //메모리 사용량 순서로 정렬</code>
        - <code>shift + t //cpu 시간 순서 정렬</code>
        - <code>shift + p //cpu 사용량 순서정렬로 돌아가기</code>

13. 로그 파일에서 필요한 줄만 뽑고 싶어
    - 